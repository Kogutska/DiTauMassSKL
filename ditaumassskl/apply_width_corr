#! /usr/bin/env python2.7
# -*- mode: python  -*-

## to apply width correction 
import os
import shutil
import ROOT
from multiprocessing import Process

## rootpy imports
from rootpy.io import root_open
from rootpy.tree import TreeModel 
from rootpy.tree import FloatCol
from rootpy.stl import vector

import numpy as np
from array import array 
## local imports
from ditaumassskl.parallel import run_pool
from ditaumassskl import log


class Model(TreeModel):
    parent_m_corr = FloatCol(default=-1111)

def get_mean_mass (tree):
    m = []
    for i, event in enumerate(tree):
        m.append(event.parent_m)    
    mn = np.array(m)
    mean = np.mean(mn)
    std = np.std(mn)
    return mean , std

def add_new_branches(tree):
   tree.create_buffer()
   tree.set_buffer(Model(), create_branches=True)
   branch = tree.GetBranch('parent_m_corr')
   mean , std = get_mean_mass(tree)
   for event in tree:
       tree.parent_m_corr = event.parent_m + ((event.parent_m - mean)/std) * 20.
       branch.Fill()
   tree.SetEntries(-1)
   
   ## get the mean and std of parent_m
   # m = []
   # for i, event in enumerate(tree):
   #    m.append(event.parent_m)
   # mn = np.array(m)   
   # mean = np.mean(mn)
   # std = np.std(mn)
   # n= i+1
   # parent_m_corr = array('f', [0]*n)
   # tree.Branch("parent_m_corr", parent_m_corr, 'parent_m_corr/F')
  

   # for i, event in enumerate(tree):   
   #    print i, event.parent_m + (event.parent_m - mean)/std * 10.
   #    #print event.parent_m + (event.parent_m - mean)/std * 10., 
   #    parent_m_corr[i] = event.parent_m + (event.parent_m - mean)/std * 10.  
   #    tree.Fill()
    
class Job(Process):
    def __init__(self, filename):
        super(Job, self).__init__()
        self.filename = filename

    def run(self):
        filename = self.filename
        path, name = os.path.split(filename)
        # copy to new file
        output = os.path.join(path, 'v1.' + name)
        if os.path.exists(output):
            return
        log.info("copying {0} to {1} ...".format(filename, output))
        shutil.copy(filename, output)
        with root_open(output, "UPDATE")as f:
            tree = f.NOMINAL
            add_new_branches(tree)
            tree.Write(tree.name, ROOT.TObject.kOverwrite)
                         
if __name__ == '__main__':
   from argparse import ArgumentParser
   parser = ArgumentParser()
   parser.add_argument('files', nargs='+')
   args = parser.parse_args()
   jobs = [Job(f) for f in args.files]
   run_pool(jobs, n_jobs=-1)
   
